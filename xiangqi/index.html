<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>象棋 — Chinese Chess</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{
  background:linear-gradient(135deg,#3e2723 0%,#4e342e 50%,#3e2723 100%);
  font-family:'Noto Serif SC','SimSun','STSong',serif;
  display:flex;justify-content:center;align-items:center;
  min-height:100vh;color:#4e342e;
  overflow-x:hidden;
}
#app{
  display:flex;flex-direction:column;align-items:center;
  padding:12px;max-width:100vw;
}
#status{
  font-size:1.1em;color:#f5e6c8;margin-bottom:8px;
  text-shadow:1px 1px 3px rgba(0,0,0,.5);
  letter-spacing:2px;min-height:1.4em;
}
#game-wrap{
  display:flex;gap:10px;align-items:flex-start;
  flex-wrap:wrap;justify-content:center;
}
.captured-zone{
  width:60px;display:flex;flex-direction:column;align-items:center;gap:2px;
  min-height:200px;
}
.captured-zone h3{
  color:#f5e6c8;font-size:.75em;writing-mode:vertical-rl;
  letter-spacing:3px;margin-bottom:4px;
}
.cap-piece{
  width:32px;height:32px;border-radius:50%;
  display:flex;align-items:center;justify-content:center;
  font-size:14px;font-weight:700;
  border:1.5px solid #8d6e63;
  background:radial-gradient(circle at 35% 35%,#fef3e0,#e8d5b7);
  box-shadow:1px 1px 3px rgba(0,0,0,.3);
}
.cap-piece.red{color:#b71c1c}
.cap-piece.black{color:#1a1a1a}
#board-container{
  position:relative;
  background:linear-gradient(145deg,#d4a762,#c9975a 30%,#d4a762 50%,#c49353 70%,#d4a762);
  border-radius:6px;
  box-shadow:0 4px 20px rgba(0,0,0,.5),inset 0 0 30px rgba(0,0,0,.08);
  border:3px solid #8d6e63;
  padding:20px;
}
canvas{display:block;cursor:pointer}
#buttons{margin-top:10px;display:flex;gap:10px}
#buttons button{
  padding:8px 20px;font-size:1em;
  font-family:inherit;cursor:pointer;
  background:linear-gradient(to bottom,#f5e6c8,#d7c4a0);
  border:2px solid #8d6e63;border-radius:4px;
  color:#4e342e;letter-spacing:1px;
  box-shadow:0 2px 4px rgba(0,0,0,.2);
  transition:all .15s;
}
#buttons button:hover{background:linear-gradient(to bottom,#fff,#e8d5b7)}
#buttons button:active{transform:translateY(1px);box-shadow:none}
@media(max-width:520px){
  #board-container{padding:10px;border-width:2px}
  .captured-zone{display:none}
  #status{font-size:.9em}
  #buttons button{padding:6px 14px;font-size:.9em}
  #game-wrap{gap:0}
}
</style>
</head>
<body>
<div id="app">
  <div id="status">請走棋 — Your turn</div>
  <div id="game-wrap">
    <div class="captured-zone" id="cap-black"><h3>黑方損失</h3></div>
    <div id="board-container"><canvas id="board"></canvas></div>
    <div class="captured-zone" id="cap-red"><h3>紅方損失</h3></div>
  </div>
  <div id="buttons">
    <button onclick="newGame()">新局 New Game</button>
    <button onclick="undoMove()">悔棋 Undo</button>
  </div>
</div>
<script>
"use strict";
// ===== CONSTANTS =====
const COLS=9,ROWS=10;
const EMPTY=0,R_JIANG=1,R_SHI=2,R_XIANG=3,R_MA=4,R_JU=5,R_PAO=6,R_BING=7;
const B_JIANG=8,B_SHI=9,B_XIANG=10,B_MA=11,B_JU=12,B_PAO=13,B_BING=14;
const PIECE_NAMES={
  [R_JIANG]:'帥',[R_SHI]:'仕',[R_XIANG]:'相',[R_MA]:'馬',[R_JU]:'車',[R_PAO]:'砲',[R_BING]:'兵',
  [B_JIANG]:'將',[B_SHI]:'士',[B_XIANG]:'象',[B_MA]:'馬',[B_JU]:'車',[B_PAO]:'砲',[B_BING]:'卒'
};
function isRed(p){return p>=1&&p<=7}
function isBlack(p){return p>=8&&p<=14}
function sideOf(p){return isRed(p)?'red':isBlack(p)?'black':null}

// ===== BOARD STATE =====
let board,turn,selected,validMoves,gameOver,history,capturedRed,capturedBlack;
let animating=false,animData=null;

const INIT_BOARD=[
  [B_JU,B_MA,B_XIANG,B_SHI,B_JIANG,B_SHI,B_XIANG,B_MA,B_JU],
  [0,0,0,0,0,0,0,0,0],
  [0,B_PAO,0,0,0,0,0,B_PAO,0],
  [B_BING,0,B_BING,0,B_BING,0,B_BING,0,B_BING],
  [0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0],
  [R_BING,0,R_BING,0,R_BING,0,R_BING,0,R_BING],
  [0,R_PAO,0,0,0,0,0,R_PAO,0],
  [0,0,0,0,0,0,0,0,0],
  [R_JU,R_MA,R_XIANG,R_SHI,R_JIANG,R_SHI,R_XIANG,R_MA,R_JU]
];

function cloneBoard(b){return b.map(r=>[...r])}
function newGame(){
  board=cloneBoard(INIT_BOARD);
  turn='red';selected=null;validMoves=[];gameOver=false;
  history=[];capturedRed=[];capturedBlack=[];
  animating=false;animData=null;
  setStatus('請走棋 — Your turn');
  draw();
}

// ===== CANVAS SETUP =====
const canvas=document.getElementById('board');
const ctx=canvas.getContext('2d');
let CW,CH,CELL,OX,OY,PIECE_R;

function resize(){
  const isMobile=window.innerWidth<600;
  const maxW=Math.min(isMobile?window.innerWidth-20:window.innerWidth-140,460);
  const maxH=window.innerHeight-120;
  CELL=Math.floor(Math.min(maxW/8,maxH/9));
  if(CELL<36)CELL=36;
  OX=CELL*0.6;OY=CELL*0.6;
  CW=OX*2+CELL*8;
  CH=OY*2+CELL*9;
  canvas.width=CW;canvas.height=CH;
  canvas.style.width=CW+'px';canvas.style.height=CH+'px';
  PIECE_R=CELL*0.42;
  draw();
}
window.addEventListener('resize',resize);

// ===== DRAWING =====
function boardX(c){return OX+c*CELL}
function boardY(r){return OY+r*CELL}

function draw(){
  ctx.clearRect(0,0,CW,CH);
  drawBoard();
  drawPieces();
  if(selected&&!animating){
    // highlight selected
    const sx=boardX(selected[1]),sy=boardY(selected[0]);
    ctx.strokeStyle='rgba(183,28,28,0.6)';ctx.lineWidth=3;
    ctx.beginPath();ctx.arc(sx,sy,PIECE_R+3,0,Math.PI*2);ctx.stroke();
    // highlight valid moves
    for(const[mr,mc] of validMoves){
      const mx=boardX(mc),my=boardY(mr);
      if(board[mr][mc]!==EMPTY){
        ctx.strokeStyle='rgba(183,28,28,0.45)';ctx.lineWidth=2.5;
        ctx.beginPath();ctx.arc(mx,my,PIECE_R+2,0,Math.PI*2);ctx.stroke();
      }else{
        ctx.fillStyle='rgba(120,80,40,0.35)';
        ctx.beginPath();ctx.arc(mx,my,CELL*0.13,0,Math.PI*2);ctx.fill();
      }
    }
  }
}

function drawBoard(){
  ctx.save();
  // lines
  ctx.strokeStyle='#5d4037';ctx.lineWidth=1.2;
  // horizontal lines
  for(let r=0;r<ROWS;r++){
    ctx.beginPath();ctx.moveTo(boardX(0),boardY(r));ctx.lineTo(boardX(8),boardY(r));ctx.stroke();
  }
  // vertical lines (with river gap for inner columns)
  for(let c=0;c<COLS;c++){
    if(c===0||c===8){
      ctx.beginPath();ctx.moveTo(boardX(c),boardY(0));ctx.lineTo(boardX(c),boardY(9));ctx.stroke();
    }else{
      ctx.beginPath();ctx.moveTo(boardX(c),boardY(0));ctx.lineTo(boardX(c),boardY(4));ctx.stroke();
      ctx.beginPath();ctx.moveTo(boardX(c),boardY(5));ctx.lineTo(boardX(c),boardY(9));ctx.stroke();
    }
  }
  // palace diagonals
  ctx.beginPath();ctx.moveTo(boardX(3),boardY(0));ctx.lineTo(boardX(5),boardY(2));ctx.stroke();
  ctx.beginPath();ctx.moveTo(boardX(5),boardY(0));ctx.lineTo(boardX(3),boardY(2));ctx.stroke();
  ctx.beginPath();ctx.moveTo(boardX(3),boardY(7));ctx.lineTo(boardX(5),boardY(9));ctx.stroke();
  ctx.beginPath();ctx.moveTo(boardX(5),boardY(7));ctx.lineTo(boardX(3),boardY(9));ctx.stroke();
  // river text
  ctx.fillStyle='#6d4c41';
  ctx.font=`bold ${CELL*0.45}px 'Noto Serif SC','STKaiti','KaiTi',serif`;
  ctx.textAlign='center';ctx.textBaseline='middle';
  const ry=boardY(4)+(boardY(5)-boardY(4))/2;
  ctx.fillText('楚 河',boardX(2),ry);
  ctx.fillText('漢 界',boardX(6),ry);
  // star points (cannon & soldier positions)
  const starPts=[[2,1],[2,7],[7,1],[7,7],[3,0],[3,2],[3,4],[3,6],[3,8],[6,0],[6,2],[6,4],[6,6],[6,8]];
  for(const[r,c] of starPts) drawStar(boardX(c),boardY(r));
  ctx.restore();
}

function drawStar(x,y){
  const s=CELL*0.1,g=CELL*0.04;
  ctx.lineWidth=1;ctx.strokeStyle='#5d4037';
  const dirs=[[-1,-1],[-1,1],[1,-1],[1,1]];
  for(const[dx,dy] of dirs){
    const sx=x+dx*g,sy=y+dy*g;
    ctx.beginPath();ctx.moveTo(sx+dx*s,sy);ctx.lineTo(sx,sy);ctx.lineTo(sx,sy+dy*s);ctx.stroke();
  }
}

function drawPiece(piece,x,y,alpha){
  if(!piece)return;
  ctx.save();
  ctx.globalAlpha=alpha||1;
  // shadow
  ctx.beginPath();ctx.arc(x+1.5,y+2,PIECE_R,0,Math.PI*2);
  ctx.fillStyle='rgba(0,0,0,0.18)';ctx.fill();
  // body
  ctx.beginPath();ctx.arc(x,y,PIECE_R,0,Math.PI*2);
  const bg=ctx.createRadialGradient(x-PIECE_R*0.3,y-PIECE_R*0.3,PIECE_R*0.1,x,y,PIECE_R);
  bg.addColorStop(0,'#fef9f0');bg.addColorStop(0.7,'#efe0c6');bg.addColorStop(1,'#d4b896');
  ctx.fillStyle=bg;ctx.fill();
  // rim
  ctx.strokeStyle='#8d6e63';ctx.lineWidth=1.5;ctx.stroke();
  // inner ring
  ctx.beginPath();ctx.arc(x,y,PIECE_R*0.82,0,Math.PI*2);
  ctx.strokeStyle=isRed(piece)?'#b71c1c':'#212121';ctx.lineWidth=1;ctx.stroke();
  // text
  ctx.fillStyle=isRed(piece)?'#b71c1c':'#1a1a1a';
  ctx.font=`bold ${PIECE_R*1.1}px 'Noto Serif SC','STKaiti','KaiTi',serif`;
  ctx.textAlign='center';ctx.textBaseline='middle';
  ctx.fillText(PIECE_NAMES[piece],x,y+1);
  ctx.restore();
}

function drawPieces(){
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
    if(animData&&animData.fr===r&&animData.fc===c)continue;
    if(animData&&animData.tr===r&&animData.tc===c&&animData.captured)continue;
    if(board[r][c])drawPiece(board[r][c],boardX(c),boardY(r));
  }
  if(animData){
    const t=animData.progress;
    const x=boardX(animData.fc)+(boardX(animData.tc)-boardX(animData.fc))*t;
    const y=boardY(animData.fr)+(boardY(animData.tr)-boardY(animData.fr))*t;
    drawPiece(animData.piece,x,y);
  }
}

// ===== SOUND =====
let audioCtx;
function ensureAudio(){if(!audioCtx)audioCtx=new(window.AudioContext||window.webkitAudioContext)()}
function playSound(type){
  try{
    ensureAudio();
    const o=audioCtx.createOscillator(),g=audioCtx.createGain();
    o.connect(g);g.connect(audioCtx.destination);
    const t=audioCtx.currentTime;
    if(type==='move'){
      o.frequency.value=440;o.type='sine';
      g.gain.setValueAtTime(0.12,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.1);
      o.start(t);o.stop(t+0.1);
    }else if(type==='capture'){
      o.frequency.value=300;o.type='triangle';
      g.gain.setValueAtTime(0.2,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.2);
      o.start(t);o.stop(t+0.2);
    }else if(type==='check'){
      o.frequency.value=660;o.type='square';
      g.gain.setValueAtTime(0.1,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.3);
      o.start(t);o.stop(t+0.3);
      const o2=audioCtx.createOscillator(),g2=audioCtx.createGain();
      o2.connect(g2);g2.connect(audioCtx.destination);
      o2.frequency.value=880;o2.type='square';
      g2.gain.setValueAtTime(0.1,t+0.12);g2.gain.exponentialRampToValueAtTime(0.001,t+0.35);
      o2.start(t+0.12);o2.stop(t+0.35);
    }
  }catch(e){}
}

// ===== MOVE LOGIC =====
function inBounds(r,c){return r>=0&&r<ROWS&&c>=0&&c<COLS}
function inPalace(r,c,side){
  if(c<3||c>5)return false;
  return side==='red'?(r>=7&&r<=9):(r>=0&&r<=2);
}

function getMoves(b,r,c){
  const p=b[r][c];if(!p)return[];
  const side=sideOf(p);const moves=[];
  const add=(nr,nc)=>{
    if(!inBounds(nr,nc))return false;
    const t=b[nr][nc];
    if(t&&sideOf(t)===side)return false;
    moves.push([nr,nc]);return true;
  };
  const baseType=isRed(p)?p:p-7;
  switch(baseType){
    case R_JIANG:
      for(const[dr,dc] of [[0,1],[0,-1],[1,0],[-1,0]]){
        const nr=r+dr,nc=c+dc;
        if(inPalace(nr,nc,side))add(nr,nc);
      }
      // flying general
      {
        const dir=side==='red'?-1:1;
        let nr=r+dir;
        while(inBounds(nr,c)&&b[nr][c]===EMPTY)nr+=dir;
        if(inBounds(nr,c)){
          const tp=b[nr][c];
          if(tp&&((isRed(p)&&tp===B_JIANG)||(isBlack(p)&&tp===R_JIANG)))
            moves.push([nr,c]);
        }
      }
      break;
    case R_SHI:
      for(const[dr,dc] of [[1,1],[1,-1],[-1,1],[-1,-1]]){
        const nr=r+dr,nc=c+dc;
        if(inPalace(nr,nc,side))add(nr,nc);
      }
      break;
    case R_XIANG:{
      const homeRows=side==='red'?[r>=5,true]:[r<=4,true];
      for(const[dr,dc] of [[2,2],[2,-2],[-2,2],[-2,-2]]){
        const nr=r+dr,nc=c+dc;
        if(!inBounds(nr,nc))continue;
        if(side==='red'&&nr<5)continue;
        if(side==='black'&&nr>4)continue;
        if(b[r+dr/2][c+dc/2]!==EMPTY)continue;
        add(nr,nc);
      }
      break;
    }
    case R_MA:
      for(const[lr,lc,dr,dc] of [[0,1,1,2],[0,1,-1,2],[0,-1,1,-2],[0,-1,-1,-2],[1,0,2,1],[1,0,2,-1],[-1,0,-2,1],[-1,0,-2,-1]]){
        if(!inBounds(r+lr,c+lc)||b[r+lr][c+lc]!==EMPTY)continue;
        add(r+dr,c+dc);
      }
      break;
    case R_JU:
      for(const[dr,dc] of [[0,1],[0,-1],[1,0],[-1,0]]){
        let nr=r+dr,nc=c+dc;
        while(inBounds(nr,nc)){
          if(b[nr][nc]){add(nr,nc);break}
          add(nr,nc);nr+=dr;nc+=dc;
        }
      }
      break;
    case R_PAO:
      for(const[dr,dc] of [[0,1],[0,-1],[1,0],[-1,0]]){
        let nr=r+dr,nc=c+dc;let jumped=false;
        while(inBounds(nr,nc)){
          if(!jumped){
            if(b[nr][nc])jumped=true;
            else moves.push([nr,nc]);
          }else{
            if(b[nr][nc]){if(sideOf(b[nr][nc])!==side)moves.push([nr,nc]);break}
          }
          nr+=dr;nc+=dc;
        }
      }
      break;
    case R_BING:{
      const dir=side==='red'?-1:1;
      add(r+dir,c);
      const crossed=side==='red'?r<=4:r>=5;
      if(crossed){add(r,c-1);add(r,c+1)}
      break;
    }
  }
  return moves;
}

function isInCheck(b,side){
  // find king
  const king=side==='red'?R_JIANG:B_JIANG;
  let kr=-1,kc=-1;
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(b[r][c]===king){kr=r;kc=c}
  if(kr<0)return true;
  const opp=side==='red'?'black':'red';
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
    if(b[r][c]&&sideOf(b[r][c])===opp){
      const m=getMoves(b,r,c);
      for(const[mr,mc] of m)if(mr===kr&&mc===kc)return true;
    }
  }
  return false;
}

function getLegalMoves(b,r,c){
  const p=b[r][c];if(!p)return[];
  const side=sideOf(p);
  const raw=getMoves(b,r,c);
  return raw.filter(([mr,mc])=>{
    const nb=cloneBoard(b);
    nb[mr][mc]=nb[r][c];nb[r][c]=EMPTY;
    return !isInCheck(nb,side);
  });
}

function allLegalMoves(b,side){
  const moves=[];
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
    if(b[r][c]&&sideOf(b[r][c])===side){
      const lm=getLegalMoves(b,r,c);
      for(const[mr,mc] of lm)moves.push([r,c,mr,mc]);
    }
  }
  return moves;
}

function makeMove(b,fr,fc,tr,tc){
  const cap=b[tr][tc];
  b[tr][tc]=b[fr][fc];b[fr][fc]=EMPTY;
  return cap;
}

// ===== UI =====
function setStatus(s){document.getElementById('status').textContent=s}

function updateCaptured(){
  const crEl=document.getElementById('cap-red');
  const cbEl=document.getElementById('cap-black');
  crEl.innerHTML='<h3>紅方損失</h3>';
  cbEl.innerHTML='<h3>黑方損失</h3>';
  for(const p of capturedRed){
    const d=document.createElement('div');d.className='cap-piece red';
    d.textContent=PIECE_NAMES[p];crEl.appendChild(d);
  }
  for(const p of capturedBlack){
    const d=document.createElement('div');d.className='cap-piece black';
    d.textContent=PIECE_NAMES[p];cbEl.appendChild(d);
  }
}

// ===== ANIMATION =====
function animateMove(fr,fc,tr,tc,piece,captured,cb){
  animating=true;
  const dur=180;
  const start=performance.now();
  animData={fr,fc,tr,tc,piece,captured,progress:0};
  function step(now){
    const t=Math.min((now-start)/dur,1);
    animData.progress=t*t*(3-2*t); // smoothstep
    draw();
    if(t<1)requestAnimationFrame(step);
    else{animData=null;animating=false;cb()}
  }
  requestAnimationFrame(step);
}

// ===== CLICK HANDLER =====
canvas.addEventListener('click',e=>{
  if(gameOver||turn!=='red'||animating)return;
  const rect=canvas.getBoundingClientRect();
  const sx=(e.clientX-rect.left)*(canvas.width/rect.width);
  const sy=(e.clientY-rect.top)*(canvas.height/rect.height);
  const c=Math.round((sx-OX)/CELL);
  const r=Math.round((sy-OY)/CELL);
  if(!inBounds(r,c))return;

  if(selected){
    // try move
    const [sr,sc]=selected;
    if(validMoves.some(([mr,mc])=>mr===r&&mc===c)){
      doPlayerMove(sr,sc,r,c);
      return;
    }
    // reselect own piece
    if(board[r][c]&&sideOf(board[r][c])==='red'){
      selected=[r,c];validMoves=getLegalMoves(board,r,c);draw();return;
    }
    selected=null;validMoves=[];draw();
  }else{
    if(board[r][c]&&sideOf(board[r][c])==='red'){
      selected=[r,c];validMoves=getLegalMoves(board,r,c);draw();
    }
  }
});

function doPlayerMove(fr,fc,tr,tc){
  const piece=board[fr][fc];
  const cap=board[tr][tc];
  history.push({fr,fc,tr,tc,cap,board:cloneBoard(board),capturedRed:[...capturedRed],capturedBlack:[...capturedBlack]});
  board[fr][fc]=EMPTY;
  selected=null;validMoves=[];
  animateMove(fr,fc,tr,tc,piece,cap,()=>{
    board[tr][tc]=piece;
    if(cap){capturedBlack.push(cap);playSound('capture')}else playSound('move');
    updateCaptured();
    if(isInCheck(board,'black'))playSound('check');
    const bm=allLegalMoves(board,'black');
    if(bm.length===0){
      gameOver=true;
      setStatus(isInCheck(board,'black')?'將死！紅方勝 — Red wins!':'和棋 — Stalemate');
      draw();return;
    }
    turn='black';
    setStatus('思考中… AI thinking…');
    draw();
    setTimeout(aiMove,400);
  });
}

function undoMove(){
  if(history.length===0||animating)return;
  // undo AI + player (2 moves)
  const steps=turn==='red'&&history.length>=2?2:1;
  for(let i=0;i<steps&&history.length>0;i++){
    const h=history.pop();
    board=h.board;capturedRed=h.capturedRed;capturedBlack=h.capturedBlack;
  }
  turn='red';selected=null;validMoves=[];gameOver=false;
  setStatus('請走棋 — Your turn');
  updateCaptured();draw();
}

// ===== AI =====
const PIECE_VALUES={
  [R_JIANG]:10000,[R_SHI]:20,[R_XIANG]:25,[R_MA]:45,[R_JU]:100,[R_PAO]:45,[R_BING]:10,
  [B_JIANG]:10000,[B_SHI]:20,[B_XIANG]:25,[B_MA]:45,[B_JU]:100,[B_PAO]:45,[B_BING]:10
};

// positional bonuses (simplified)
const POS_MA=[[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,1,3,2,2,2,3,1,0],[0,2,4,4,4,4,4,2,0],[1,3,4,5,4,5,4,3,1],[1,3,4,5,4,5,4,3,1],[0,2,4,4,4,4,4,2,0],[0,1,3,2,2,2,3,1,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]];
const POS_PAO=[[0,0,1,0,0,0,1,0,0],[0,1,0,0,0,0,0,1,0],[1,2,3,2,3,2,3,2,1],[0,1,2,2,2,2,2,1,0],[0,0,1,1,1,1,1,0,0],[0,0,1,1,1,1,1,0,0],[0,1,2,2,2,2,2,1,0],[1,2,3,2,3,2,3,2,1],[0,1,0,0,0,0,0,1,0],[0,0,1,0,0,0,1,0,0]];

function evaluate(b){
  let score=0;
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
    const p=b[r][c];if(!p)continue;
    const v=PIECE_VALUES[p];
    const bt=isRed(p)?p:p-7;
    let pos=0;
    if(bt===R_MA)pos=POS_MA[r][c]*2;
    else if(bt===R_PAO)pos=POS_PAO[r][c];
    else if(bt===R_BING){
      const crossed=isRed(p)?(r<=4):(r>=5);
      if(crossed)pos=5;
    }else if(bt===R_JU){
      // center file bonus
      if(c===4)pos=3;
    }
    if(isRed(p))score+=v+pos;
    else score-=v+pos;
  }
  return score;
}

function aiMove(){
  const depth=3;
  let bestScore=Infinity,bestMove=null;
  const moves=allLegalMoves(board,'black');
  // sort for better pruning
  moves.sort((a,b)=>{
    const ca=board[a[2]][a[3]]?PIECE_VALUES[board[a[2]][a[3]]]:0;
    const cb=board[b[2]][b[3]]?PIECE_VALUES[board[b[2]][b[3]]]:0;
    return cb-ca;
  });
  let alpha=-Infinity,beta=Infinity;
  for(const[fr,fc,tr,tc] of moves){
    const nb=cloneBoard(board);
    makeMove(nb,fr,fc,tr,tc);
    const s=minimax(nb,depth-1,alpha,beta,true);
    if(s<bestScore){bestScore=s;bestMove=[fr,fc,tr,tc]}
    beta=Math.min(beta,s);
  }
  if(!bestMove){
    gameOver=true;setStatus('黑方無子可走 — Red wins!');draw();return;
  }
  const[fr,fc,tr,tc]=bestMove;
  const piece=board[fr][fc];
  const cap=board[tr][tc];
  history.push({fr,fc,tr,tc,cap,board:cloneBoard(board),capturedRed:[...capturedRed],capturedBlack:[...capturedBlack]});
  board[fr][fc]=EMPTY;
  animateMove(fr,fc,tr,tc,piece,cap,()=>{
    board[tr][tc]=piece;
    if(cap){capturedRed.push(cap);playSound('capture')}else playSound('move');
    updateCaptured();
    if(isInCheck(board,'red'))playSound('check');
    const rm=allLegalMoves(board,'red');
    if(rm.length===0){
      gameOver=true;
      setStatus(isInCheck(board,'red')?'將死！黑方勝 — Black wins!':'和棋 — Stalemate');
      draw();return;
    }
    turn='red';
    setStatus(isInCheck(board,'red')?'將軍！請應將 — Check!':'請走棋 — Your turn');
    draw();
  });
}

function minimax(b,depth,alpha,beta,maximizing){
  if(depth===0)return evaluate(b);
  const side=maximizing?'red':'black';
  const moves=allLegalMoves(b,side);
  if(moves.length===0){
    return isInCheck(b,side)?(maximizing?-99999:99999):0;
  }
  if(maximizing){
    let best=-Infinity;
    for(const[fr,fc,tr,tc] of moves){
      const nb=cloneBoard(b);makeMove(nb,fr,fc,tr,tc);
      best=Math.max(best,minimax(nb,depth-1,alpha,beta,false));
      alpha=Math.max(alpha,best);if(alpha>=beta)break;
    }
    return best;
  }else{
    let best=Infinity;
    for(const[fr,fc,tr,tc] of moves){
      const nb=cloneBoard(b);makeMove(nb,fr,fc,tr,tc);
      best=Math.min(best,minimax(nb,depth-1,alpha,beta,true));
      beta=Math.min(beta,best);if(alpha>=beta)break;
    }
    return best;
  }
}

// ===== INIT =====
newGame();resize();
</script>
</body>
</html>
